diff --git a/examples/media-sender/main.cpp b/examples/media-sender/main.cpp
index 7c923eb4..d9fcc747 100644
--- a/examples/media-sender/main.cpp
+++ b/examples/media-sender/main.cpp
@@ -11,10 +11,20 @@
 #include "rtc/rtc.hpp"
 
 #include <cstddef>
+#include <cerrno>
+#include <chrono>
+#include <cstring>
+#include <fstream>
 #include <iostream>
 #include <memory>
+#include <mutex>
+#include <atomic>
+#include <optional>
 #include <stdexcept>
+#include <string>
+#include <thread>
 #include <utility>
+#include <vector>
 
 #include <nlohmann/json.hpp>
 
@@ -29,27 +39,399 @@ typedef int SOCKET;
 #endif
 
 using nlohmann::json;
+using namespace std::chrono_literals;
 
 const int BUFFER_SIZE = 2048;
 
-int main() {
+static std::vector<std::vector<std::byte>> parseAnnexBNalus(const std::vector<std::byte> &data) {
+	std::vector<std::vector<std::byte>> nalus;
+	const size_t size = data.size();
+	size_t i = 0;
+
+	auto isStartCode = [&](size_t pos, size_t &len) {
+		if (pos + 3 >= size)
+			return false;
+		if (data[pos] == std::byte{0x00} && data[pos + 1] == std::byte{0x00}) {
+			if (data[pos + 2] == std::byte{0x01}) {
+				len = 3;
+				return true;
+			}
+			if (pos + 3 < size && data[pos + 2] == std::byte{0x00} &&
+			    data[pos + 3] == std::byte{0x01}) {
+				len = 4;
+				return true;
+			}
+		}
+		return false;
+	};
+
+	while (i + 3 < size) {
+		size_t startLen = 0;
+		while (i + 3 < size && !isStartCode(i, startLen))
+			++i;
+		if (i + 3 >= size)
+			break;
+		size_t start = i + startLen;
+		i = start;
+
+		size_t nextLen = 0;
+		while (i + 3 < size && !isStartCode(i, nextLen))
+			++i;
+		size_t end = i;
+		if (end > start) {
+			nalus.emplace_back(data.begin() + start, data.begin() + end);
+		}
+	}
+
+	return nalus;
+}
+
+static std::vector<rtc::binary> buildFramesFromNalus(
+    const std::vector<std::vector<std::byte>> &nalus) {
+	bool hasAud = false;
+	for (const auto &nalu : nalus) {
+		if (nalu.empty())
+			continue;
+		uint8_t type = static_cast<uint8_t>(nalu[0]) & 0x1F;
+		if (type == 9) {
+			hasAud = true;
+			break;
+		}
+	}
+
+	std::vector<rtc::binary> frames;
+	std::optional<std::vector<std::byte>> lastSps;
+	std::optional<std::vector<std::byte>> lastPps;
+
+	auto pushFrame = [&](const std::vector<std::vector<std::byte>> &frameNalus) {
+		rtc::binary frame;
+		for (const auto &nalu : frameNalus) {
+			static const std::byte startCode[4] = {std::byte{0x00}, std::byte{0x00},
+			                                      std::byte{0x00}, std::byte{0x01}};
+			frame.insert(frame.end(), std::begin(startCode), std::end(startCode));
+			frame.insert(frame.end(), nalu.begin(), nalu.end());
+		}
+		if (!frame.empty())
+			frames.emplace_back(std::move(frame));
+	};
+
+	if (hasAud) {
+		std::vector<std::vector<std::byte>> current;
+		bool hasSps = false;
+		bool hasPps = false;
+
+		for (const auto &nalu : nalus) {
+			if (nalu.empty())
+				continue;
+			uint8_t type = static_cast<uint8_t>(nalu[0]) & 0x1F;
+			if (type == 7) {
+				lastSps = nalu;
+				hasSps = true;
+			} else if (type == 8) {
+				lastPps = nalu;
+				hasPps = true;
+			}
+
+			if (type == 9) {
+				if (!current.empty()) {
+					pushFrame(current);
+					current.clear();
+					hasSps = false;
+					hasPps = false;
+				}
+				continue;
+			}
+
+			if (type == 5) {
+				if (lastSps && !hasSps) {
+					current.push_back(*lastSps);
+					hasSps = true;
+				}
+				if (lastPps && !hasPps) {
+					current.push_back(*lastPps);
+					hasPps = true;
+				}
+			}
+
+			current.push_back(nalu);
+		}
+		if (!current.empty())
+			pushFrame(current);
+	} else {
+		for (const auto &nalu : nalus) {
+			if (nalu.empty())
+				continue;
+			uint8_t type = static_cast<uint8_t>(nalu[0]) & 0x1F;
+			if (type == 7)
+				lastSps = nalu;
+			else if (type == 8)
+				lastPps = nalu;
+
+			std::vector<std::vector<std::byte>> frameNalus;
+			if (type == 5) {
+				if (lastSps)
+					frameNalus.push_back(*lastSps);
+				if (lastPps)
+					frameNalus.push_back(*lastPps);
+			}
+			frameNalus.push_back(nalu);
+			pushFrame(frameNalus);
+		}
+	}
+
+	return frames;
+}
+
+int main(int argc, char **argv) {
 	try {
 		rtc::InitLogger(rtc::LogLevel::Debug);
-		auto pc = std::make_shared<rtc::PeerConnection>();
-
-		pc->onStateChange(
-		    [](rtc::PeerConnection::State state) { std::cout << "State: " << state << std::endl; });
-
-		pc->onGatheringStateChange([pc](rtc::PeerConnection::GatheringState state) {
-			std::cout << "Gathering State: " << state << std::endl;
-			if (state == rtc::PeerConnection::GatheringState::Complete) {
-				auto description = pc->localDescription();
-				json message = {{"type", description->typeString()},
-				                {"sdp", std::string(description.value())}};
-				std::cout << message << std::endl;
+
+		std::string signalingHost = "127.0.0.1";
+		uint16_t signalingPort = 8000;
+		std::string localId = "sender";
+		std::string remoteId = "browser";
+		std::string h264FilePath;
+		uint32_t fps = 30;
+		bool loopFile = true;
+
+		for (int i = 1; i < argc; ++i) {
+			std::string arg = argv[i];
+			if (arg == "--signaling-ip" && i + 1 < argc) {
+				signalingHost = argv[++i];
+			} else if (arg == "--signaling-port" && i + 1 < argc) {
+				signalingPort = static_cast<uint16_t>(std::stoi(argv[++i]));
+			} else if (arg == "--local-id" && i + 1 < argc) {
+				localId = argv[++i];
+			} else if (arg == "--remote-id" && i + 1 < argc) {
+				remoteId = argv[++i];
+			} else if (arg == "--h264-file" && i + 1 < argc) {
+				h264FilePath = argv[++i];
+			} else if (arg == "--fps" && i + 1 < argc) {
+				fps = static_cast<uint32_t>(std::stoi(argv[++i]));
+			} else if (arg == "--no-loop") {
+				loopFile = false;
+			} else if (arg == "--help") {
+				std::cout << "usage: media-sender [--signaling-ip IP] [--signaling-port PORT] "
+				             "[--local-id ID] [--remote-id ID] [--h264-file PATH] [--fps N] "
+				             "[--no-loop]\n";
+				return 0;
+			} else {
+				std::cerr << "Unknown argument: " << arg << std::endl;
+				return 1;
 			}
+		}
+		if (fps == 0) {
+			std::cerr << "Invalid fps: 0" << std::endl;
+			return 1;
+		}
+
+		auto ws = std::make_shared<rtc::WebSocket>();
+		bool wsOpen = false;
+		std::string pendingOffer;
+		std::mutex pcMutex;
+		std::shared_ptr<rtc::PeerConnection> pc;
+		std::shared_ptr<rtc::Track> track;
+		std::atomic<bool> idle{true};
+		std::atomic<int64_t> lastPacketMs{0};
+		std::atomic<bool> reconnecting{false};
+
+		ws->onOpen([&]() {
+			wsOpen = true;
+			std::cout << "WebSocket connected, signaling ready" << std::endl;
+		});
+
+		ws->onError([](const std::string &error) {
+			std::cout << "WebSocket failed: " << error << std::endl;
 		});
 
+		ws->onClosed([&]() {
+			wsOpen = false;
+			std::cout << "WebSocket closed" << std::endl;
+		});
+
+		// Handle signaling messages (request/answer)
+		ws->onMessage([&](rtc::message_variant data) {
+			if (!std::holds_alternative<std::string>(data))
+				return;
+
+			json message = json::parse(std::get<std::string>(data), nullptr, false);
+			if (message.is_discarded())
+				return;
+
+			const auto typeIt = message.find("type");
+			if (typeIt == message.end())
+				return;
+			const std::string type = typeIt->get<std::string>();
+
+			if (type == "answer") {
+				const auto sdpIt = message.find("sdp");
+				if (sdpIt == message.end())
+					return;
+				std::shared_ptr<rtc::PeerConnection> currentPc;
+				{
+					std::lock_guard<std::mutex> lock(pcMutex);
+					currentPc = pc;
+				}
+				if (currentPc) {
+					rtc::Description answer(sdpIt->get<std::string>(), "answer");
+					currentPc->setRemoteDescription(answer);
+					std::cout << "Applied remote answer" << std::endl;
+				}
+			} else if (type == "request" || type == "ready") {
+				if (!pendingOffer.empty() && wsOpen) {
+					json offerMessage = {{"id", remoteId}, {"type", "offer"}, {"sdp", pendingOffer}};
+					ws->send(offerMessage.dump());
+					std::cout << "Sent offer to " << remoteId << std::endl;
+				}
+			}
+		});
+
+		const std::string url = "ws://" + signalingHost + ":" + std::to_string(signalingPort) +
+		                        "/" + localId;
+		std::cout << "WebSocket URL is " << url << std::endl;
+		ws->open(url);
+
+		std::cout << "Waiting for signaling to be connected..." << std::endl;
+		while (!wsOpen) {
+			if (ws->isClosed())
+				throw std::runtime_error("WebSocket closed before connection");
+			std::this_thread::sleep_for(100ms);
+		}
+
+		const rtc::SSRC ssrc = 42;
+		const uint8_t payloadType = 96;
+		const bool useFile = !h264FilePath.empty();
+		auto createPeerConnection = [&]() {
+			reconnecting = true;
+			auto newPc = std::make_shared<rtc::PeerConnection>();
+
+			newPc->onStateChange([](rtc::PeerConnection::State state) {
+				std::cout << "State: " << state << std::endl;
+			});
+
+			newPc->onGatheringStateChange(
+			    [newPc, ws, &pendingOffer, &wsOpen, &remoteId](rtc::PeerConnection::GatheringState state) {
+				    std::cout << "Gathering State: " << state << std::endl;
+				    if (state == rtc::PeerConnection::GatheringState::Complete) {
+					    auto description = newPc->localDescription();
+					    json message = {{"type", description->typeString()},
+					                    {"sdp", std::string(description.value())}};
+					    std::cout << "Local description ready" << std::endl;
+					    pendingOffer = message["sdp"].get<std::string>();
+					    if (wsOpen) {
+						    json offerMessage = {{"id", remoteId},
+						                         {"type", "offer"},
+						                         {"sdp", pendingOffer}};
+						    ws->send(offerMessage.dump());
+						    std::cout << "Sent offer to " << remoteId << std::endl;
+					    }
+				    }
+			    });
+
+			rtc::Description::Video media("video", rtc::Description::Direction::SendOnly);
+			media.addH264Codec(payloadType); // Must match the payload type of the H264 stream
+			media.addSSRC(ssrc, "video-send");
+			auto newTrack = newPc->addTrack(media);
+
+			if (useFile) {
+				auto rtpConfig = std::make_shared<rtc::RtpPacketizationConfig>(
+				    ssrc, "video-send", payloadType, rtc::H264RtpPacketizer::ClockRate);
+				auto packetizer = std::make_shared<rtc::H264RtpPacketizer>(
+				    rtc::NalUnit::Separator::StartSequence, rtpConfig);
+				auto srReporter = std::make_shared<rtc::RtcpSrReporter>(rtpConfig);
+				packetizer->addToChain(srReporter);
+				auto nackResponder = std::make_shared<rtc::RtcpNackResponder>();
+				packetizer->addToChain(nackResponder);
+				newTrack->setMediaHandler(packetizer);
+			}
+
+			newPc->setLocalDescription();
+
+			{
+				std::lock_guard<std::mutex> lock(pcMutex);
+				if (pc)
+					pc->close();
+				pc = newPc;
+				track = newTrack;
+			}
+			reconnecting = false;
+		};
+
+		createPeerConnection();
+
+		if (useFile)
+			std::cout << "Streaming H264 file: " << h264FilePath << std::endl;
+		else
+			std::cout << "RTP video stream expected on localhost:6000" << std::endl;
+		std::cout << "Waiting for answer via signaling..." << std::endl;
+
+		std::thread watchdog([&]() {
+			const int64_t idleThresholdMs = 2000;
+			while (true) {
+				if (!wsOpen || reconnecting)
+					std::this_thread::sleep_for(200ms);
+				int64_t nowMs = std::chrono::duration_cast<std::chrono::milliseconds>(
+				                    std::chrono::steady_clock::now().time_since_epoch())
+				                    .count();
+				int64_t lastMs = lastPacketMs.load();
+				if (lastMs != 0 && (nowMs - lastMs) > idleThresholdMs && !idle.load()) {
+					std::cout << "RTP idle detected, renegotiating..." << std::endl;
+					idle = true;
+					pendingOffer.clear();
+					createPeerConnection();
+				}
+				std::this_thread::sleep_for(200ms);
+			}
+		});
+		watchdog.detach();
+
+		if (useFile) {
+			std::ifstream input(h264FilePath, std::ios::binary);
+			if (!input)
+				throw std::runtime_error("Failed to open H264 file: " + h264FilePath);
+			std::vector<char> fileChars((std::istreambuf_iterator<char>(input)),
+			                            std::istreambuf_iterator<char>());
+			std::vector<std::byte> fileData;
+			fileData.resize(fileChars.size());
+			if (!fileChars.empty())
+				std::memcpy(fileData.data(), fileChars.data(), fileChars.size());
+			auto nalus = parseAnnexBNalus(fileData);
+			auto frames = buildFramesFromNalus(nalus);
+			if (frames.empty())
+				throw std::runtime_error("No frames parsed from H264 file");
+
+			uint64_t frameIndex = 0;
+			while (true) {
+				std::shared_ptr<rtc::Track> currentTrack;
+				{
+					std::lock_guard<std::mutex> lock(pcMutex);
+					currentTrack = track;
+				}
+				if (!currentTrack || !currentTrack->isOpen()) {
+					std::this_thread::sleep_for(50ms);
+					continue;
+				}
+
+				const auto &frame = frames[frameIndex];
+				double seconds = static_cast<double>(frameIndex) / static_cast<double>(fps);
+				rtc::FrameInfo info{std::chrono::duration<double>(seconds)};
+				currentTrack->sendFrame(frame, info);
+				lastPacketMs = std::chrono::duration_cast<std::chrono::milliseconds>(
+				                   std::chrono::steady_clock::now().time_since_epoch())
+				                   .count();
+				idle = false;
+
+				frameIndex++;
+				if (frameIndex >= frames.size()) {
+					if (loopFile)
+						frameIndex = 0;
+					else
+						frameIndex = frames.size() - 1;
+				}
+				std::this_thread::sleep_for(std::chrono::milliseconds(1000 / fps));
+			}
+		}
+
 		SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);
 		struct sockaddr_in addr = {};
 		addr.sin_family = AF_INET;
@@ -63,34 +445,43 @@ int main() {
 		setsockopt(sock, SOL_SOCKET, SO_RCVBUF, reinterpret_cast<const char *>(&rcvBufSize),
 		           sizeof(rcvBufSize));
 
-		const rtc::SSRC ssrc = 42;
-		rtc::Description::Video media("video", rtc::Description::Direction::SendOnly);
-		media.addH264Codec(96); // Must match the payload type of the external h264 RTP stream
-		media.addSSRC(ssrc, "video-send");
-		auto track = pc->addTrack(media);
-
-		pc->setLocalDescription();
-
-		std::cout << "RTP video stream expected on localhost:6000" << std::endl;
-		std::cout << "Please copy/paste the answer provided by the browser: " << std::endl;
-		std::string sdp;
-		std::getline(std::cin, sdp);
+		// Receive from UDP (keep running even if the sender stops/restarts)
+		char buffer[BUFFER_SIZE];
+		while (true) {
+			int len = recv(sock, buffer, BUFFER_SIZE, 0);
+			if (len < 0) {
+				if (errno == EINTR)
+					continue;
+				std::cerr << "recv failed: " << std::strerror(errno) << std::endl;
+				std::this_thread::sleep_for(200ms);
+				continue;
+			}
 
-		json j = json::parse(sdp);
-		rtc::Description answer(j["sdp"].get<std::string>(), j["type"].get<std::string>());
-		pc->setRemoteDescription(answer);
+			std::shared_ptr<rtc::Track> currentTrack;
+			{
+				std::lock_guard<std::mutex> lock(pcMutex);
+				currentTrack = track;
+			}
 
-		// Receive from UDP
-		char buffer[BUFFER_SIZE];
-		int len;
-		while ((len = recv(sock, buffer, BUFFER_SIZE, 0)) >= 0) {
-			if (len < sizeof(rtc::RtpHeader) || !track->isOpen())
+			if (!currentTrack || len < static_cast<int>(sizeof(rtc::RtpHeader)) ||
+			    !currentTrack->isOpen())
 				continue;
 
+			lastPacketMs = std::chrono::duration_cast<std::chrono::milliseconds>(
+			                   std::chrono::steady_clock::now().time_since_epoch())
+			                   .count();
+			idle = false;
+
 			auto rtp = reinterpret_cast<rtc::RtpHeader *>(buffer);
 			rtp->setSsrc(ssrc);
 
-			track->send(reinterpret_cast<const std::byte *>(buffer), len);
+			try {
+				currentTrack->send(reinterpret_cast<const std::byte *>(buffer), len);
+			} catch (const std::exception &e) {
+				std::cerr << "Track send error: " << e.what() << std::endl;
+				pendingOffer.clear();
+				createPeerConnection();
+			}
 		}
 
 	} catch (const std::exception &e) {
diff --git a/examples/media-sender/main.html b/examples/media-sender/main.html
index 3092391b..7a05adcf 100644
--- a/examples/media-sender/main.html
+++ b/examples/media-sender/main.html
@@ -6,41 +6,108 @@
 </head>
 <body>
 
-<p>Please enter the offer provided to you by the sender application: </p>
-<textarea cols="80" rows="25"></textarea>
-<button>Submit</button>
+<p id="status">Connecting to signaling...</p>
+<textarea id="log" cols="80" rows="12" readonly></textarea>
 
 <video id="video-element" muted></video>
 
 <script>
-    document.querySelector('button').addEventListener('click',  async () => {
-        const offer = JSON.parse(document.querySelector('textarea').value);
-        const pc = new RTCPeerConnection({
+    const statusEl = document.getElementById('status');
+    const logEl = document.getElementById('log');
+    const signalingUrl = 'ws://127.0.0.1:8000/browser';
+    const remoteId = 'sender';
+
+    function log(line) {
+        logEl.value += line + '\n';
+        logEl.scrollTop = logEl.scrollHeight;
+    }
+
+    let pc = null;
+    let ws = null;
+    const reconnectIntervalMs = 5000;
+    const maxReconnectTotalMs = 30000;
+    let reconnectTimer = null;
+    let reconnectAttempts = 0;
+
+    function createPeerConnection() {
+        if (pc) {
+            pc.close();
+        }
+        pc = new RTCPeerConnection({
             // Recommended for libdatachannel
             bundlePolicy: 'max-bundle',
         });
 
-        pc.onicegatheringstatechange = (state) => {
-            if (pc.iceGatheringState === 'complete') {
+        pc.onicegatheringstatechange = () => {
+            if (pc.iceGatheringState === 'complete' && ws && ws.readyState === WebSocket.OPEN) {
                 // We only want to provide an answer once all of our candidates have been added to the SDP.
                 const answer = pc.localDescription;
-                document.querySelector('textarea').value = JSON.stringify({"type": answer.type, sdp: answer.sdp});
-                document.querySelector('p').value = 'Please paste the answer in the sender application.';
-                alert('Please paste the answer in the sender application.');
+                ws.send(JSON.stringify({id: remoteId, type: answer.type, sdp: answer.sdp}));
+                statusEl.textContent = 'Answer sent. Waiting for media...';
+                log('Answer sent');
             }
+        };
+
+        pc.ontrack = (evt) => {
+            const videoElement = document.getElementById('video-element');
+            videoElement.srcObject = evt.streams[0];
+            videoElement.play();
+            statusEl.textContent = 'Streaming';
+        };
+    }
+
+    function scheduleReconnect() {
+        if (reconnectTimer) {
+            return;
+        }
+        if (reconnectAttempts * reconnectIntervalMs >= maxReconnectTotalMs) {
+            statusEl.textContent = 'Signaling disconnected. Giving up.';
+            return;
         }
+        reconnectTimer = setTimeout(() => {
+            reconnectTimer = null;
+            reconnectAttempts += 1;
+            connectSignaling();
+        }, reconnectIntervalMs);
+    }
 
-		pc.ontrack = (evt) => {
-			const videoElement = document.getElementById('video-element');
-			videoElement.srcObject = evt.streams[0];
-			videoElement.play();
-		};
+    function connectSignaling() {
+        ws = new WebSocket(signalingUrl);
+
+        ws.onopen = () => {
+            statusEl.textContent = 'Signaling connected. Requesting offer...';
+            reconnectAttempts = 0;
+            ws.send(JSON.stringify({id: remoteId, type: 'request'}));
+        };
+
+        ws.onerror = () => {
+            statusEl.textContent = 'Signaling error';
+        };
+
+        ws.onclose = () => {
+            statusEl.textContent = 'Signaling disconnected. Reconnecting...';
+            scheduleReconnect();
+        };
+
+        ws.onmessage = async (evt) => {
+            if (typeof evt.data !== 'string') {
+                return;
+            }
+            const message = JSON.parse(evt.data);
+            if (message.type !== 'offer') {
+                return;
+            }
+            statusEl.textContent = 'Offer received. Creating answer...';
+            log('Offer received');
 
-        await pc.setRemoteDescription(offer);
+            createPeerConnection();
+            await pc.setRemoteDescription(message);
+            const answer = await pc.createAnswer();
+            await pc.setLocalDescription(answer);
+        };
+    }
 
-        const answer = await pc.createAnswer();
-        await pc.setLocalDescription(answer);
-    })
+    connectSignaling();
 </script>
 
 </body>
