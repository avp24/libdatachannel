<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>libdatachannel media sender example</title>
</head>
<body>

<p id="status">Connecting to signaling...</p>
<textarea id="log" cols="80" rows="12" readonly></textarea>

<video id="video-element" muted></video>

<script>
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    <!--const signalingUrl = 'ws://127.0.0.1:8000/browser'; -->
    const signalingUrl = 'ws://192.168.1.110:8000/browser';
    const remoteId = 'sender';
    const stunUrl = 'stun:stun.l.google.com:19302';
    const turnUrl = '';
    const turnUser = '';
    const turnPass = '';
    const turnTransport = 'udp';

    function log(line) {
        logEl.value += line + '\n';
        logEl.scrollTop = logEl.scrollHeight;
    }

    let pc = null;
    let ws = null;
    const reconnectIntervalMs = 5000;
    const maxReconnectTotalMs = 30000;
    let reconnectTimer = null;
    let reconnectAttempts = 0;

    function createPeerConnection() {
        if (pc) {
            pc.close();
        }
        const iceServers = [];
        if (stunUrl) {
            iceServers.push({urls: [stunUrl]});
        }
        if (turnUrl) {
            const turnEntry = {urls: [turnUrl], username: turnUser, credential: turnPass};
            if (turnTransport === 'tcp' || turnTransport === 'tls') {
                turnEntry.urls = [`${turnUrl}?transport=${turnTransport}`];
            }
            iceServers.push(turnEntry);
        }

        pc = new RTCPeerConnection({
            // Recommended for libdatachannel
            bundlePolicy: 'max-bundle',
            iceServers: iceServers,
        });

        pc.onicegatheringstatechange = () => {
            if (pc.iceGatheringState === 'complete' && ws && ws.readyState === WebSocket.OPEN) {
                // We only want to provide an answer once all of our candidates have been added to the SDP.
                const answer = pc.localDescription;
                ws.send(JSON.stringify({id: remoteId, type: answer.type, sdp: answer.sdp}));
                statusEl.textContent = 'Answer sent. Waiting for media...';
                log('Answer sent');
            }
        };

        pc.onicecandidate = (evt) => {
            if (evt.candidate) {
                log('ICE candidate: ' + evt.candidate.candidate);
            }
        };

        pc.oniceconnectionstatechange = () => {
            log('ICE connection state: ' + pc.iceConnectionState);
        };

        pc.onsignalingstatechange = () => {
            log('Signaling state: ' + pc.signalingState);
        };

        pc.ontrack = (evt) => {
            const videoElement = document.getElementById('video-element');
            videoElement.srcObject = evt.streams[0];
            videoElement.play();
            statusEl.textContent = 'Streaming';
        };
    }

    function scheduleReconnect() {
        if (reconnectTimer) {
            return;
        }
        if (reconnectAttempts * reconnectIntervalMs >= maxReconnectTotalMs) {
            statusEl.textContent = 'Signaling disconnected. Giving up.';
            return;
        }
        reconnectTimer = setTimeout(() => {
            reconnectTimer = null;
            reconnectAttempts += 1;
            connectSignaling();
        }, reconnectIntervalMs);
    }

    function connectSignaling() {
        ws = new WebSocket(signalingUrl);

        ws.onopen = () => {
            statusEl.textContent = 'Signaling connected. Requesting offer...';
            reconnectAttempts = 0;
            ws.send(JSON.stringify({id: remoteId, type: 'request'}));
        };

        ws.onerror = () => {
            statusEl.textContent = 'Signaling error';
        };

        ws.onclose = () => {
            statusEl.textContent = 'Signaling disconnected. Reconnecting...';
            scheduleReconnect();
        };

        ws.onmessage = async (evt) => {
            if (typeof evt.data !== 'string') {
                return;
            }
            const message = JSON.parse(evt.data);
            if (message.type !== 'offer') {
                return;
            }
            statusEl.textContent = 'Offer received. Creating answer...';
            log('Offer received');

            createPeerConnection();
            await pc.setRemoteDescription(message);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
        };
    }

    connectSignaling();
</script>

</body>
</html>
